## âœ… Unit 3: Software Requirement Analysis and Specifications, Design & Software Reliability
ðŸ”¹ Problem Analysis
Understanding the actual needs or issues of the end-user.

Focus on identifying gaps and inconsistencies in requirements.

ðŸ”¹ Data Flow Diagrams (DFDs)
Graphical tool to represent the flow of data in a system.

Helps in modeling input, processing, and output stages.

ðŸ”¹ Use Case Diagrams
Part of UML; represents interactions between users (actors) and the system.

Visualizes functional requirements.

ðŸ”¹ Software Prototyping
Creating a working model of the system to refine requirements.

Types: throwaway, evolutionary, incremental, and extreme prototyping.

ðŸ”¹ Cohesion and Coupling
Cohesion: Degree to which elements inside a module belong together.

Coupling: Degree of interdependence between software modules.

High cohesion + low coupling = better design.

ðŸ”¹ Function Oriented Design
Focus on functions and their flow.

Breaks system into smaller functional modules.

ðŸ”¹ Object-Oriented Design (OOD)
Emphasizes objects, classes, inheritance, encapsulation, and polymorphism.

ðŸ”¹ User Interface (UI) Design
Designing the look and feel of the system's interface for user interaction.

ðŸ”¹ Software Reliability
Ability of software to perform without failure under specified conditions.

Concerns: Failure, Faults, and Errors.

ðŸ”¹ Quality Standards
ISO 9001: Ensures consistent quality in processes.

SEI-CMM (Capability Maturity Model): Measures the maturity of software development processes.

## âœ… Unit 4: Software Testing
ðŸ”¹ Software Testing Terminology
Bug, Error, Defect, Failure, etc.

Testing types: Static vs. Dynamic, Black-box vs. White-box

ðŸ”¹ Functional Testing Techniques
Boundary Value Analysis (BVA): Tests at the edges of input ranges.

Equivalence Class Testing: Groups inputs into valid and invalid partitions.

ðŸ”¹ Cause-Effect Graphing
Converts input conditions and output actions into a graphical representation for designing test cases.

ðŸ”¹ Structural Testing
Also called White-box Testing.

Includes:

Path Testing: Checks all possible execution paths.

Data Flow Testing: Focuses on variablesâ€™ lifecycle (definition, usage, deletion).

Mutation Testing: Checks code robustness by introducing small faults.

ðŸ”¹ Types of Testing
Unit Testing: Test individual modules/functions.

Integration Testing: Test combined modules for interface issues.

System Testing: Tests the entire system as a whole.

Validation Testing: Ensures product meets the userâ€™s needs.

ðŸ”¹ Debugging Techniques
Locating and fixing bugs using methods like backtracking, cause elimination, and brute force.

ðŸ”¹ Testing Tools
Examples: JUnit, Selenium, Postman, LoadRunner, etc.